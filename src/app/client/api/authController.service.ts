/**
 * Sistema de gestión de órdenes de carga de gas líquido - IW3
 * API para gestionar órdenes de carga de gas líquido. Esto serealiza creando una orden de carga, adjuntando datos como el preset, tara, etc,a la orden de carga. Finalmente se cierra la orden de carga, la cual puedeser consultada en el futuro. Cada orden de carga pasa por 4 estados: E1, E2, E3 y E4. Se utilizó una dependencia llamada Lombok que ayudó bastante a la hora de hacer getters y setters, constructores y autowired. <strong> IMPLEMENTADO POR PACHA, LEONEL Y CANO, ELIANA </strong>
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { RequestDeLOGIN } from '../model/requestDeLOGIN';
import { SignupRequest } from '../model/signupRequest';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class AuthControllerService {

    protected basePath = 'http://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Devuelve el usuario actualmente logueado
     * 
     * @param tokenEncript tokenEncript
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public authInfoUsingGET(tokenEncript: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public authInfoUsingGET(tokenEncript: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public authInfoUsingGET(tokenEncript: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public authInfoUsingGET(tokenEncript: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (tokenEncript === null || tokenEncript === undefined) {
            throw new Error('Required parameter tokenEncript was null or undefined when calling authInfoUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (tokenEncript !== undefined && tokenEncript !== null) {
            queryParameters = queryParameters.set('tokenEncript', <any>tokenEncript);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/api/v1/auth-info`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Login al servidor
     * 
     * @param loginRequest loginRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loginUsingPOST(loginRequest: RequestDeLOGIN, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public loginUsingPOST(loginRequest: RequestDeLOGIN, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public loginUsingPOST(loginRequest: RequestDeLOGIN, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public loginUsingPOST(loginRequest: RequestDeLOGIN, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (loginRequest === null || loginRequest === undefined) {
            throw new Error('Required parameter loginRequest was null or undefined when calling loginUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/api/v1/login`,
            loginRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cierra la sesión actual
     * 
     * @param token token
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public logoutUsingPOST(token: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public logoutUsingPOST(token: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public logoutUsingPOST(token: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public logoutUsingPOST(token: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling logoutUsingPOST.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (token !== undefined && token !== null) {
            queryParameters = queryParameters.set('token', <any>token);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<any>(`${this.basePath}/api/v1/logout`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Registro en el servidor
     * 
     * @param signupRequest signupRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registroUsingPOST(signupRequest: SignupRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public registroUsingPOST(signupRequest: SignupRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public registroUsingPOST(signupRequest: SignupRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public registroUsingPOST(signupRequest: SignupRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (signupRequest === null || signupRequest === undefined) {
            throw new Error('Required parameter signupRequest was null or undefined when calling registroUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/api/v1/sign-up`,
            signupRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
